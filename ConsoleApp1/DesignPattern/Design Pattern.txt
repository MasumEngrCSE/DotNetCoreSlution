Creational Patterns:
Singleton Pattern: Ensures a class has only one instance and provides a global point of access to that instance.
Factory Method Pattern: Defines an interface for creating objects, but lets subclasses decide which class to instantiate.
Abstract Factory Pattern: Provides an interface for creating families of related or dependent objects without specifying their concrete classes.
Builder Pattern: Separates the construction of a complex object from its representation, allowing the same construction process to create different representations.
Prototype Pattern: Creates new objects by copying an existing object, which acts as a prototype.

Structural Patterns:
Adapter Pattern: Allows objects with incompatible interfaces to work together by providing a wrapper that converts one interface into another.
Bridge Pattern: Decouples an abstraction from its implementation, allowing both to evolve independently.
Composite Pattern: Composes objects into tree structures to represent part-whole hierarchies. It lets clients treat individual objects and compositions of objects uniformly.
Decorator Pattern: Dynamically adds responsibilities to objects without modifying their code.
Facade Pattern: Provides a simplified interface to a complex system of classes, acting as a higher-level interface.

Behavioral Patterns:
Observer Pattern: Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.
Strategy Pattern: Defines a family of algorithms, encapsulates each algorithm, and makes them interchangeable. Clients can switch algorithms without altering their code.
Command Pattern: Turns a request into a standalone object containing all information about the request. This decouples sender and receiver.
Chain of Responsibility Pattern: Lets more than one object handle a request without knowing which object will process it.
State Pattern: Allows an object to change its behavior when its internal state changes.
